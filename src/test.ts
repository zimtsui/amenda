/*
	This test is generated by AI.
 */
import test from 'ava';
import { Draft, Controlflow, Finalized } from './exports.ts';

// Test Finalized exception
test('Finalized extends Error', t => {
	const finalized = new Finalized('test message');
	t.true(finalized instanceof Error);
	t.true(finalized instanceof Finalized);
	t.is(finalized.message, 'test message');
});

// --- Draft Tests ---

test('Draft.eta creates a draft that yields a value then completes', async t => {
	const draft = Draft.eta('test');
	const result1 = await draft.next();
	t.false(result1.done);
	t.is(result1.value, 'test');
	const result2 = await draft.next();
	t.true(result2.done);
});

test('Draft.from converts a Promise to a Draft', async t => {
	const promise = Promise.resolve('promised value');
	const draft = Draft.from(promise);
	const result1 = await draft.next();
	t.false(result1.done);
    t.is(result1.value, 'promised value');
	const result2 = await draft.next();
	t.true(result2.done);
});

test('Draft.to converts a Draft to a Promise, finalizing the draft', async t => {
	let isFinalized = false;
	const draft = (async function* (): Draft<string> {
		try {
			return yield 'final value';
		} catch (e) {
			if (e instanceof Finalized) {
				isFinalized = true;
			}
			throw e;
		}
	})();

	const value = await Draft.to(draft);
	t.is(value, 'final value');
	t.true(isFinalized);
});

test('Draft.map transforms values and handles revisions', async t => {
    let value = 10;
	const draft = (async function* (): Draft<number> {
		for (;;) {
			try {
				return yield value;
			} catch (e) {
                if (e instanceof Error && e.message === 'revise') {
                    value = 20;
                } else {
                    throw e;
                }
			}
		}
	})();

    const mappedDraft = Draft.map((x: number) => x * 2)(draft);

    const result1 = await mappedDraft.next();
    t.is(result1.value, 20);

    const result2 = await mappedDraft.throw(new Error('revise'));
    t.is(result2.value, 40);
});

test('Draft.mu flattens a nested Draft', async t => {
    let innerValue = 'first';
	const innerDraft = (async function* (): Draft<string> {
		for (;;) {
			try {
				return yield innerValue;
			} catch (e) {
                if (e instanceof Error && e.message === 'revise inner') {
                    innerValue = 'second';
                } else {
                    throw e;
                }
			}
		}
	})();

    const outerDraft = Draft.eta(innerDraft);
    const flattened = Draft.mu(outerDraft);

    const result1 = await flattened.next();
    t.is(result1.value, 'first');

    const result2 = await flattened.throw(new Error('revise inner'));
    t.is(result2.value, 'second');
});

// --- Controlflow Tests ---

test('Controlflow.of creates a controlflow from a draft', async t => {
	const draft = Draft.eta('test');
	const cf = Controlflow.of(draft);
	t.is(await cf.first(), 'test');
});

test('Controlflow.from creates a controlflow from a value', async t => {
	const cf = Controlflow.from('test');
	t.is(await cf.first(), 'test');
});

test('Controlflow.create creates a void controlflow', async t => {
	const cf = Controlflow.create();
	t.is(await cf.first(), undefined);
});

test('controlflow.first() consumes the draft and returns the first value', async t => {
	const cf = Controlflow.from('test');
	t.is(await cf.first(), 'test');
});

test('controlflow.pipe applies a draft transformation', async t => {
	const cf = Controlflow.from(10);
	const piped = cf.pipe(Draft.map(x => x / 2));
	t.is(await piped.first(), 5);
});

test('controlflow.then chains a draft-returning function', async t => {
	const cf = Controlflow.from('test');
	const chained = cf.then(x => Draft.eta(x + ' then'));
	t.is(await chained.first(), 'test then');
});

test('controlflow.transform chains a promise-returning function', async t => {
	const cf = Controlflow.from('test');
	const transformed = cf.transform(async x => x.toUpperCase());
	t.is(await transformed.first(), 'TEST');
});

test('controlflow.map chains a value-returning function', async t => {
	const cf = Controlflow.from(5);
	const mapped = cf.map(x => x * 3);
	t.is(await mapped.first(), 15);
});

// --- Workflow Pattern Tests ---

test('Conditional workflow pattern', async t => {
	const determineLanguage = async (text: string) => {
		if (text.includes('你好')) return 'Chinese';
		if (text.includes('привет')) return 'Russian';
		return 'English';
	};

	const translateChineseToEnglish = async function* (text: string): Draft<string> {
		return yield `Translated from Chinese: ${text}`;
	};

	const translateRussianToEnglish = async function* (text: string): Draft<string> {
		return yield `Translated from Russian: ${text}`;
	};

	const cf = Controlflow.from('你好世界')
		.then(async function* (mathProblem: string): Draft<string> {
			switch (await determineLanguage(mathProblem)) {
				case 'Chinese': return yield* translateChineseToEnglish(mathProblem);
				case 'Russian': return yield* translateRussianToEnglish(mathProblem);
				case 'English': return yield mathProblem;
				default: throw new Error('Language Not Supported');
			}
		});

	const result = await cf.first();
	t.is(result, 'Translated from Chinese: 你好世界');
});

test('Optimizer-evaluator pattern', async t => {
	let attemptCount = 0;

	const generateCode = async function* (): Draft<string> {
		for (;;) {
			attemptCount++;
			const code = attemptCount === 1 ? 'invalid code' : 'function test() {}';
			try {
				return yield code;
			} catch (e) {
				if (e instanceof Finalized) {
					throw e;
				}
                // Revise based on other feedback
			}
		}
	};

	const syntaxCheck = (code: string): void => {
		if (!code.includes('function')) {
			throw new Error('Invalid syntax');
		}
	};

	const evaluator = async function* (optimization: Draft<string>): Draft<string> {
		let feedback: unknown;
		for (;;) {
			const r = feedback === undefined
				? await optimization.next()
				: await optimization.throw(feedback);
			try {
				const code = r.value;
				syntaxCheck(code);
				return yield code;
			} catch (e) {
				feedback = e;
			}
		}
	};

	const cf = Controlflow.create()
		.then(generateCode)
		.pipe(evaluator);

	const result = await cf.first();
	t.is(result, 'function test() {}');
	t.is(attemptCount, 2);
});

test('Parallel workflow pattern', async t => {
	const translateChineseToEnglish = async function* (text: string): Draft<string> {
		return yield `English: ${text}`;
	};

	const translateChineseToRussian = async function* (text: string): Draft<string> {
		return yield `Russian: ${text}`;
	};

	const cf = Controlflow.from('中文')
		.transform(async (chinese: string) => {
			const [english, russian] = await Promise.all([
				Controlflow.from(chinese).then(translateChineseToEnglish).first(),
				Controlflow.from(chinese).then(translateChineseToRussian).first(),
			]);
			return `# Chinese: ${chinese}\n# English: ${english}\n# Russian: ${russian}`;
		});

	const result = await cf.first();
	const expected = '# Chinese: 中文\n# English: English: 中文\n# Russian: Russian: 中文';
	t.is(result, expected);
});
